using System;
using StackExchange.Redis;
using Xunit;

namespace Redis101Examples
{
    static class StreamExercises
    {
        public static void Exercises(IDatabase db)
        {
            Console.WriteLine("Running Stream exercises...");
            db.KeyDelete("hero:organizations");

            // Publish to a stream.  Not supplying a streamId causes one to be generated by Redis using the timestamp default.
            // If the stream does not exist then it is created when StreamAdd is called.
            // Differences from Pub/Sub
            // - Every client (consumer) will receive a copy of any item added to the stream
            // - All messages appended to a stream will be available for future retrieval unless explicitly deleted
            // - Consumer Groups provide process acknowledgement, inspection of pending items, message claiming, and per-client private history, which is unavailable to pub/sub

            // 1. Add an entry with a single name-value pair to the stream
            RedisValue firstMessageId = db.StreamAdd("hero:organizations", "name", "Wasp", messageId: "*");
            Assert.True(firstMessageId.HasValue);
            
            // Add an entry with multiple name-value pairs to the stream
            var streamPairs1 = new NameValueEntry[]
            {
                new("name", "Hulk"),
                new("affiliation", "Avengers")
            };

            var streamPairs2 = new NameValueEntry[]
            {
                new("name", "Iron Man"),
                new("affiliation", "Avengers")
            };

            RedisValue secondMessageId = db.StreamAdd("hero:organizations", streamPairs1, messageId: "*");
            Assert.True(secondMessageId.HasValue);

            RedisValue thirdMessageId = db.StreamAdd("hero:organizations", streamPairs2, messageId: "*");
            Assert.True(thirdMessageId.HasValue);
            
            // 2. Read from a stream. This will return all messages
            //    from the 'position' through the end of the stream
            //    unless a count is given
            StreamEntry[] firstMessage = db.StreamRead("hero:organizations", "0", count: 1);
            Assert.Equal("Wasp", firstMessage[0]["name"]);
            // Returning more than one StreamEntry
            StreamEntry[] streamFromZero = db.StreamRead("hero:organizations", "0");
            Assert.Equal("Hulk", streamFromZero[1]["name"]);
            Assert.Equal("Avengers", streamFromZero[2]["affiliation"]);

            // StreamRange is used to read a consecutive set of IDs.
            // The characters `+` and `-` are used to indicate the minimum and maximum possible IDs.
            // If no value is passed to the respective parameters the entire stream will be read.
            StreamEntry[] rangeOfMessages = db.StreamRange("hero:organizations", minId: "-", maxId: "+");
            Assert.Equal(3, rangeOfMessages.Length);
             
            StreamEntry[] fromSecondMessageId = db.StreamRange("hero:organizations", minId: secondMessageId, maxId: "+");
            Assert.Equal(2, fromSecondMessageId.Length);
            
            
            // StreamInfo can be used to gather information about a stream.
            StreamInfo info = db.StreamInfo("hero:organizations");
            Assert.Equal(3 ,info.Length);

            // ConsumerGroups
            // Consumer groups act as an logical endpoint for a stream. The individual consumers are then served by the consumer group.
            // Using a consumer group provides certain guarantees
            // - Each message will only be sent once to a single client
            // - Consumers are identified within the consumer group by a unique case-sensitive string which allows the consumer group to retain state in the event of a consumer disconnect
            // - The consumer group maintains a state of the last message ID processed by a consumer which allows pending messages for a consumer to be process in order
            // - Consuming pending messages requires an explicit acknowledgement which gives the ability to enforce processing guarantees
            // - Consumer groups track pending messages, where pending is defined as, messages delivered to a consumer but know yet acknowledged. This mechanism means that each consumer sees only its own message history

            // CreateConsumerGroup
            // If the referenced stream does not exist when the consumer group is created, this will create the stream
            // If the first visible message to the new group requires a position other than the beginning of the stream or the first new message after joining,
            // position can be specified by giving a specific message ID instead of a `StreamPosition` constant.

            // Synchronous
            bool created = db.StreamCreateConsumerGroup("hero:organizations", "hero_consumer_group1", StreamPosition.Beginning);
            Assert.True(created);

            // A named consumer is created if it doesn't already exist in the consumer group.
            // `>` is a special character that means, "read not delivered to any consumer"
            // Count limits the returned messages to the count quantity.
            // If a message ID is passed instead of the `>` character, the pending messages for that consumer are 
            // searched and if a message with a matching ID is found, that StreamEntry is returned.
            StreamEntry[] shieldConsumerEntries =
                db.StreamReadGroup("hero:organizations", "hero_consumer_group1", "shield", ">", count: 1);
            Assert.Equal("Wasp", shieldConsumerEntries[0]["name"]);

            
            // Read a message for a second consumer in the same consumer group
            StreamEntry[] aimConsumerEntries =
                db.StreamReadGroup("hero:organizations", "hero_consumer_group1", "AIM", ">", count: 1);
            Assert.Equal("Hulk", aimConsumerEntries[0]["name"]);
            Assert.Equal("Avengers", aimConsumerEntries[0]["affiliation"]);
            
            
            // StreamPending
            // StreamPending returns high level state information about a given consumers messages
            StreamPendingInfo streamPendingInfo = db.StreamPending("hero:organizations", "hero_consumer_group1");
            Assert.Equal(2,streamPendingInfo.PendingMessageCount);

            StreamPendingMessageInfo[] aimPendingInfo =
                db.StreamPendingMessages("hero:organizations", "hero_consumer_group1", 10, "AIM");
            Assert.Single(aimPendingInfo);
            Assert.Equal("AIM",aimPendingInfo[0].ConsumerName);
            Assert.Equal(secondMessageId,aimPendingInfo[0].MessageId);
            
            // StreamPendingMessages
            // StreamPendingMessages shows detailed message information about pending messages for a given consumer
            StreamPendingMessageInfo[] shieldPendingInfo =
                db.StreamPendingMessages("hero:organizations", "hero_consumer_group1", 10, "shield");
            Assert.Single(shieldPendingInfo);
            Assert.Equal("shield",shieldPendingInfo[0].ConsumerName);
            Assert.Equal(firstMessageId,shieldPendingInfo[0].MessageId);

            // StreamAcknowledge
            // This will send an ACK to the consumer group for the given message ID, removing it from the pending messages for the consumer
            var acknowledgedCount = db.StreamAcknowledge("hero:organizations", "hero_consumer_group1", firstMessageId);
            Assert.Equal(1, acknowledgedCount);

            StreamPendingInfo pendingInfoAfterAck = db.StreamPending("hero:organizations", "hero_consumer_group1");
            Assert.Equal(1,pendingInfoAfterAck.PendingMessageCount);
            
            // StreamDeleteConsumer
            // This will delete the given consumer from the consumer group.  There is a separate delete commands for consumer groups, and stream messages
            var aimDeletedPending = db.StreamDeleteConsumer("hero:organizations", "hero_consumer_group1", "AIM");
            Assert.Equal(1,aimDeletedPending);
            var shieldDeletedPending = db.StreamDeleteConsumer("hero:organizations", "hero_consumer_group1", "shield");
            Assert.Equal(0,shieldDeletedPending);
            
            // StreamDeleteConsumerGroup
            bool deleted = db.StreamDeleteConsumerGroup("hero:organizations", "hero_consumer_group1");
            Assert.True(deleted);
        }
    }
}