using System;
using System.Text;
using StackExchange.Redis;

namespace Redis101Examples
{
    class Program
    {
        static void Main(string[] args)
        {
            // Configuration options and patterns
            string redisConfiguration = "localhost:6380"; // Store *basic* information in a string
            var options = ConfigurationOptions.Parse(redisConfiguration); // create a ConfigurationOptions instance
            options.AllowAdmin = true; // and set specific details with options
            options.Ssl = false;
            options.ConnectRetry = 1;
            options.HighPrioritySocketThreads = true;
            
            // Multiplexor is intended to be reused
            ConnectionMultiplexer redisMultiplexer = ConnectionMultiplexer.Connect(options);
            
            // The database reference is a lightweight passthrough object intended to be used and discarded
            IDatabase db = redisMultiplexer.GetDatabase();
            
            // All Redis commands and data types are supported and available through the API

            StringExercises.stringExercises(db);

            HashExercises.hashExercises(db);

            ListExercises.listExercises(db);

            SetExercises.setExercises(db);

            SortedSetExercises.sortedSetExercises(db);

            GeoLocationExercises.geoLocationExercises(db);

            HllExercises.hllExercises(db);

            // Streams
            
            // Publish to a stream.  Not supplying a streamId causes one to be generated by Redis using the timestamp default.
            // If the stream does not exist then it is created when StreamAdd is called.
            // Differences from Pub/Sub
            // - Every client (consumer) will receive a copy of any item added to the stream
            // - All messages appended to a stream will be available for future retrieval unless explicitly deleted
            // - Consumer Groups provide process acknowledgement, inspection of pending items, message claiming, and per-client private history, which is unavailable to pub/sub
            
            // Add an entry with a single name-value pair to the stream
            RedisValue streamMessageId = db.StreamAdd("hero:organization", "name", "Wasp", messageId:"*");
            
            // Add an entry with multiple name-value pairs to the stream
            var streamPairs = new NameValueEntry[]
            {
                new NameValueEntry("name", "Iron Man"),
                new NameValueEntry("affiliation", "Avengers")
            };
            
            RedisValue otherMessageSteamId = db.StreamAdd("hero:organizations", streamPairs, messageId:"*");
            
            // Reading from a stream 
            
            // StreamRead - this will return all messages from the ID until the end of the stream unless a count is given
            StreamEntry[] firstMessage = db.StreamRead("hero:organization", "0", count: 1);
            
            // StreamRange is used to read a consecutive set of IDs.  The characters `+` and `-` are used to indicate the minimum and maximum possible IDs.
            // If no value is passed to the respective parameters the entire stream will be read.
            StreamEntry[] rangeOfMessages = db.StreamRange("hero:organization", minId: "0", maxId: "1");
            
            // StreamInfo can be used to gather information about a stream.
            StreamInfo info = db.StreamInfo("hero:organization");
            Console.WriteLine(info.Length);
            Console.WriteLine(info.FirstEntry);
            Console.WriteLine(info.LastEntry);
            
            // ConsumerGroup
            
            // StreamReadGroup
            
            // StreamPending
            
            // StreamAcknowledge
            
            // PubSub
            // Async vs Sync handlers
            // Sequential vs Concurrent message handling
            // Differences from Streams
            // - Pub/Sub has no history, messages are fire and forget
            // - 
            
            // Similar to the IDatabase object, this is a lightweight pass-through object to be used and discarded
            ISubscriber subscription = redisMultiplexer.GetSubscriber();
            
            // subscribing to a channel V1
            subscription.Subscribe("customer:request:events", (channel, message) =>
            {
                Console.WriteLine("Something that does something in response to {0}", message);
            });
            
            // subscribing to a channel; v2
            // Synchronous - messages are processed in the order received but may delay each other and code hampers scalability
            subscription.Subscribe("customer:completed:requests").OnMessage(message =>
            {
                Console.WriteLine("Do some work when message, {0}, is received.", message);
            });
            
            // subscribing to a channel; v2
            // Asynchronous - messages are published concurrently and the code is a more scalable 
            subscription.Subscribe("customer:completed:requests").OnMessage(async message =>
            {
                Console.WriteLine("Do some work when message, {0}, is received.", message);
            });
            
            // publish to a channel (same in v1 and v2)
            subscription.Publish("customer:request:events", "New Customer Request");
        }
    }
}